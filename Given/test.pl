% Prolog test file
%
%%%%%%%%%  reminder to staff: do NOT edit this file by hand.
%                             it was generated automatically.
%

% for a specific part, to test everything interactively:
%    -- enter gprolog:
%          gprolog
%    -- consult the files for these tests and for your code:
%          consult('../test.pl').
%          consult('sched.pl').
%    -- use one of the ty predicates to test everything
%       for example, in part 1, give the command:
%          ty1.
%    -- exit gprolog:
%          ^D
%    -- compare your output vs. correct output:
%          diff Output.correct Output.your
%       or
%          tkdiff Output.correct Output.your
%
%       files must be identical.
%
%
% you might find some of the other functions below helpful in your testing
% e.g., to test all of part2 (and all of part1)
%       w/o writing to Output.your, use
%          test-part2.
% e.g., to test only all of part2 but none of part1
%        w/o writing to Output.your, use
%          test-only-part2.

% the format of each test differs slightly from
% the equivalent interactive test, although it is straightforward to
% extract the interactive test if you want to test something
% individually, as you might during debugging.  roughly:
%  -- remove the ``all'' predicate and any string arguments (e.g., "X" or "Z").
%  -- add parentheses after predicate name.
%  -- put . at end instead of , (if necessary).
% E.g.,
%	all3iio( delete, [1], 1, Z, "Z")
% represents
%	delete( [1], 1, Z ).

testOneSaveOutput(TestPartFunction) :-
       saveOutputBegin,
       testOne(TestPartFunction),
       saveOutputEnd.
testOne(TestPartFunction) :-
       call(TestPartFunction).
       
saveOutputBegin :- tell('Output.your').
saveOutputEnd :- told.

% control UNSORTED testing; by default, it is turned off.
:- dynamic(testUnsorted/1).
testUnsorted(false).    
testUnsortedShow :- 
    assertz(testUnsorted(true)).
% note of interest only to writer (not to user) of test.pl: 
%    considered other ways to handle unsorted, but decided this was easiest.
%       e.g., could:
%         (1) generate it and filter it out via shell script.
%         (2) use telling predicate to test whether outputting to file
%             (telling(X) will give X=user
%              if so, change via tell('Output.yoursUnsorted')
%             and later restore via tell (or append).

% part tests (each tests all previous parts and all in this part)
% output saved to a file
ty1 :- testOneSaveOutput( test_part1).
ty2 :- testOneSaveOutput( test_part2).
ty3 :- testOneSaveOutput( test_part3).
ty4 :- testOneSaveOutput( test_part4).
ty5 :- testOneSaveOutput( test_part5).
ty6 :- testOneSaveOutput( test_part6).
ty7 :- testOneSaveOutput( test_part7).
ty8 :- testOneSaveOutput( test_part8).
% part tests (each tests all previous parts and all in this part)
test_part1 :- test_only_part1.
test_part2 :-
	test_part1,
	test_only_part2.
test_part3 :-
	test_part2,
	test_only_part3.
test_part4 :-
	test_part3,
	test_only_part4.
test_part5 :-
	test_part4,
	test_only_part5.
test_part6 :-
	test_part5,
	test_only_part6.
test_part7 :-
	test_part6,
	test_only_part7.
test_part8 :-
	test_part7,
	test_only_part8.
% some shorthands, so that you can just type, e.g., tp1
tp1 :- test_part1.
tp2 :- test_part2.
tp3 :- test_part3.
tp4 :- test_part4.
tp5 :- test_part5.
tp6 :- test_part6.
tp7 :- test_part7.
tp8 :- test_part8.
top1 :- test_only_part1.
top2 :- test_only_part2.
top3 :- test_only_part3.
top4 :- test_only_part4.
top5 :- test_only_part5.
top6 :- test_only_part6.
top7 :- test_only_part7.
top8 :- test_only_part8.
% part specific tests
test_only_part1 :- test_np.
test_only_part2 :-
	test_insert,
	test_butlast,
	test_naaa.
test_only_part3 :-
	test_splitlist,
	test_split3list.
test_only_part4 :-
	test_perm,
	test_permsub.
test_only_part5 :-
	test_fit1stRequest,
	test_fitRelease.
test_only_part6 :- test_fitanyRequest.
test_only_part7 :-
	test_fit1st,
	test_fitany.
test_only_part8 :-
	test_fit1stTryHarder,
	test_fitanyTryHarder.
% some abbreviations, so that you can just type, e.g., tn
tn :- test_np.
ti :- test_insert.
tb :- test_butlast.
tna :- test_naaa.
ts :- test_splitlist.
ts3 :- test_split3list.
tp :- test_perm.
tps :- test_permsub.
tx1 :- test_fit1stRequest.
ty :- test_fitRelease.
txa :- test_fitanyRequest.
t1 :- test_fit1st.
ta :- test_fitany.
t1h :- test_fit1stTryHarder.
tah :- test_fitanyTryHarder.

/* define some facts for the first part.
 * note: these facts, of course, only approximate a few national parks.
 * see www.nps.gov for complete information.
 */
np(grandcanyon,           [az,ut],     [hiking, camping]).
np(yosemite,              [ca],        [hiking, camping, rockclimbing]).
np(everglades,            [fl],        [swimming, camping]).
np(drytortugas,           [fl],        [swimming, snorkeling]).
np(lassen,                [ca],        [hiking, camping, skiing]).
np(deathvalley,           [ca,nv],     [hiking, warmup]).
np(ww2valorinthepacific,  [hi,ca,ak],  [historicalstudies]).
np(dinosaur,              [co,ut],     [excavating, hiking]).
np(bryce,                 [ut],        [camping, hiking]).
np(denali,                [ak],        [camping, hiking]).
np(zion,                  [ut],        [hiking, camping]).

test_np :-
	nl, printstring("TESTING np"), nl, nl,
	all1o(  np_names, N, "Name"),
	all1o(  np_names_not_yosemite, N, "Name"),
	all1o(  np_activities_yosemite, A, "Activity"),
	all1o(  np_states_yosemite, S, "State"),
	all1o(  np_states_grandcanyon, S, "State"),
	all2io( np_states, yosemite, S, "State"),
	all2io( np_states, grandcanyon, S, "State"),
	all2io( np_states, deathvalley, S, "State"),
	all1o(  np_sorted_activities_yosemite, A, "Activity"),
	all1o(  np_single_state, S, "State"),
	all1o(  np_multi_state, S, "State"),
	all1o(  np_pair_names, N, "Pair of Names"),
	all1o(  np_2_state_2_activities, N, "Name"),

	test_an_or( np_12_states_1or ),
	test_an_or( np_12_states_2wo ),

	test_an_or( np_camping_hiking_1or ),
	test_an_or( np_camping_hiking_2wo ),
	test_an_or( np_camping_hiking_sort ).

test_an_or(Which) :-
	nl, printstring("TESTING an OR "), write(Which), nl, nl,
	T =..[Which, N],
        findall(N, call(T), LN),
        sort(LN, SortedLN),
	printstring("Sorted_List_of_parks"), printstring(" = "),
	write(SortedLN), nl, nl.

test_insert :-
	nl, printstring("TESTING insert"), nl, nl,
	all3iio(  insert, [], 3, Z, "Z" ),
	all3iio(  insert, [1], 0, Z, "Z" ),
	all3iio(  insert, [1], 2, Z, "Z" ),
	all3iio(  insert, [1,5], 0, Z, "Z" ),
	all3iio(  insert, [1,5], 2, Z, "Z" ),
	all3iio(  insert, [1,5], 9, Z, "Z" ),
	all3iio(  insert, [1,5,8], 0, Z, "Z" ),
	all3iio(  insert, [1,5,8], 2, Z, "Z" ),
	all3iio(  insert, [1,5,8], 6, Z, "Z" ),
	all3iio(  insert, [1,5,8], 9, Z, "Z" ).

test_butlast :-
	nl, printstring("TESTING butlast"), nl, nl,
	all2io(  butlast, [], Z, "Z" ),
	all2io(  butlast, [1], Z, "Z" ),
	all2io(  butlast, [1,2], Z, "Z" ),
	all2io(  butlast, [1,2,3], Z, "Z" ),
	all2io(  butlast, [[1,2,3]], Z, "Z" ),
	all2io(  butlast, [1,[2,3]], Z, "Z" ).

test_naaa :-
	nl, printstring("TESTING naaa"), nl, nl,
	all3ioo(  naaa, [], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1,2], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a,b], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1,a], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a,1], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1,a,2], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a,1,b], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1,a,2,3,b,c,d,e,4], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a,1,2,4,3,c,d,b], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [1,2,3,4], NAL, AL, "NAL", "AL" ),
	all3ioo(  naaa, [a,c,d,b], NAL, AL, "NAL", "AL" ).

test_splitlists :-
	test_splitlist,
	test_split3list.

test_splitlist :-
	nl, printstring("TESTING splitlist"), nl, nl,
	all4ioio(  splitlist, [], Left, 2, Right, "Left", "Right" ),
        L0 = [1, 2, 3],
	all4ioio(  splitlist, L0, Left, 2, Right, "Left", "Right" ),
	all4ioio(  splitlist, L0, Left, 1, Right, "Left", "Right" ),
	all4ioio(  splitlist, L0, Left, 3, Right, "Left", "Right" ),
        L1 = [1, 2, 3, 4, 5, 6],
	all4ioio(  splitlist, L1, Left, 3, Right, "Left", "Right" ),
	all4ioio(  splitlist, L1, Left, 2, Right, "Left", "Right" ),
	all4ioio(  splitlist, L1, Left, 1, Right, "Left", "Right" ),
	all4ioio(  splitlist, L1, Left, 5, Right, "Left", "Right" ),
	all4ioio(  splitlist, L1, Left, 6, Right, "Left", "Right" ),
	all4ioio(  splitlist, L1, Left, 4, Right, "Left", "Right" ),
        L2 = [4, 2, 1, 5, 3],
	all4ioio(  splitlist, L2, Left, 3, Right, "Left", "Right" ),
	all4ioio(  splitlist, L2, Left, 2, Right, "Left", "Right" ),
	all4ioio(  splitlist, L2, Left, 1, Right, "Left", "Right" ),
	all4ioio(  splitlist, L2, Left, 5, Right, "Left", "Right" ),
	all4ioio(  splitlist, L2, Left, 6, Right, "Left", "Right" ),
	all4ioio(  splitlist, L2, Left, 4, Right, "Left", "Right" ).

test_split3list :-
	nl, printstring("TESTING split3list"), nl, nl,
	all5iiooo(  split3list, [], 2, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, [[0,9,a]], a, Left, Pivot, Right, "Left", "Pivot", "Right" ),
        L1 = [[0,9,a],[12,15,b],[22,25,c]],
	all5iiooo(  split3list, L1, b, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L1, c, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L1, a, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	L2 = [[0,9,c],[12,15,a],[22,25,b]],
	all5iiooo(  split3list, L2, b, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L2, c, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L2, a, Left, Pivot, Right, "Left", "Pivot", "Right" ),
        L3 = [[0,9,a],[12,15,b],[22,25,c],[33,5,d],[41,2,e]],
	all5iiooo(  split3list, L3, a, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L3, b, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L3, c, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L3, d, Left, Pivot, Right, "Left", "Pivot", "Right" ),
	all5iiooo(  split3list, L3, e, Left, Pivot, Right, "Left", "Pivot", "Right" ).

test_perms :-
	test_perm,
	test_permsub.

test_perm :-
	nl, printstring("TESTING perm"), nl, nl,
	test_a_perm(perm).

test_permsub :-
	nl, printstring("TESTING permsub"), nl, nl,
	test_a_perm(permsub).

test_a_perm(Which) :-
	nl, printstring("TESTING a perm "), write(Which), nl, nl,
	all2io(  Which, [], Z, "Z" ),
	all2io(  Which, [1], Z, "Z" ),
	all2io(  Which, [1,2], Z, "Z" ),
	all2io(  Which, [1,2,3], Z, "Z" ),
	all2io(  Which, [a], Z, "Z" ),
	all2io(  Which, [a,b], Z, "Z" ),
	all2io(  Which, [a,b,c], Z, "Z" ),
	all2io(  Which, [a,1,b], Z, "Z" ),
	all2io(  Which, [1,a,2], Z, "Z" ),
	all2io(  Which, [a,1,b,2], Z, "Z" ),
	all2io(  Which, [a,1,2,b], Z, "Z" ).

test_fit1stRR :-
	test_fit1stRequest,
	test_fitRelease.

test_fit1stRequest :-
	nl, printstring("TESTING fit1stRequest"), nl, nl,
	test_a_request(fit1stRequest).

test_fitanyRequest :-
	nl, printstring("TESTING fitanyRequest"), nl, nl,
	test_a_request(fitanyRequest).

% reminder:
%   in all MemLists  [a1,s1,_],[a2,_,_]  a1+s1=a2
test_a_request(Which) :-
	nl, printstring("TESTING a request "), write(Which), nl, nl,
	all3iio(  Which, [], [[0,9,z]], M, "M" ),
	all3iio(  Which, [a,9], [[0,9,z]], M, "M" ),
	all3iio(  Which, [a,9], [[0,8,z]], M, "M" ),
	all3iio(  Which, [a,2], [[0,9,z]], M, "M" ),


	all3iio(  Which, [a,32], [[0,9,z]], M, "M" ),
	all3iio(  Which, [b,3], [[0,2,a],[2,7,z]], M, "M" ),
	all3iio(  Which, [b,3], [[0,8,a],[8,1,z]], M, "M" ),
	all3iio(  Which, [c,2], [[0,2,a],[2,3,b],[5,4,z]], M, "M" ),

	% for fit1st: does it allocate 1st? for fitany: does it allocate each?
	all3iio(  Which, [d,2], [[0,2,a],[2,2,z],[4,2,b],[6,2,z],[8,2,c],[10,2,z]], M, "M" ),
        % allocated block (possibly) in middle
	all3iio(  Which, [d,5], [[0,3,z],[3,6,b],[9,3,z]], M, "M" ),
        % allocated block (possibly) in middle
	all3iio(  Which, [a,2], [[0,2,e],[2,6,f],[8,2,z]], M, "M" ).

test_fitRelease :-
	nl, printstring("TESTING fitRelease"), nl, nl,
	all3iio(  fitRelease, a, [[0,9,a]], M, "M" ),

	all3iio(  fitRelease, a, [[0,2,a],[2,7,z]], M, "M" ),
	all3iio(  fitRelease, a, [[0,2,a],[2,3,b],[5,4,z]], M, "M" ),
	all3iio(  fitRelease, b, [[0,2,a],[2,3,b],[5,4,z]], M, "M" ),

        % coalesce combines?
	all3iio(  fitRelease, a, [[0,3,z],[3,3,a],[6,2,c],[8,1,z]], M, "M" ),
	all3iio(  fitRelease, a, [[0,3,a],[3,3,z],[6,2,c],[8,1,z]], M, "M" ),
	all3iio(  fitRelease, a, [[0,3,c],[3,3,z],[6,2,a],[8,1,b]], M, "M" ),
	all3iio(  fitRelease, a, [[0,3,c],[3,3,z],[6,2,a],[8,1,z]], M, "M" ),

	all3iio(  fitRelease, a, [[0,3,a],[3,3,b],[6,2,c],[8,1,z]], M, "M" ),
	all3iio(  fitRelease, b, [[0,3,a],[3,3,b],[6,2,c],[8,1,z]], M, "M" ),
	all3iio(  fitRelease, c, [[0,3,a],[3,3,b],[6,2,c],[8,1,z]], M, "M" ).

test_fit1st :-
	nl, printstring("TESTING fit1st"), nl, nl,
	test_a_fit(0, fit1st).

test_fitany :-
	nl, printstring("TESTING fitany"), nl, nl,
	test_a_fit(0, fitany).

test_fit1stTryHarder :-
	nl, printstring("TESTING fit1stTryHarder"), nl, nl,
	test_a_fit(1, fit1stTryHarder).

test_fitanyTryHarder :-
	nl, printstring("TESTING fitanyTryHarder"), nl, nl,
	test_a_fit(1, fitanyTryHarder).

test_a_fit(TryHarderFlag, Which) :-
	nl, printstring("TESTING a fit "), write(Which), nl, nl,
	all3or4(  TryHarderFlag, Which, [], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,9]], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,9]], [[0,8,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2]], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,32]], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],a], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],a,[b,3],b], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],a,b], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],b,a], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,8],a,[b,3],b], [[0,9,z]], RR, M, "RR", "M" ),
        % reclaim?
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],a,[c,3]], [[0,6,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],b,[c,3]], [[0,6,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],a,[c,2]], [[0,6,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],b,[c,2]], [[0,6,z]], RR, M, "RR", "M" ),
        % fails:
	all3or4(  TryHarderFlag, Which, [[a,8],[b,3],a,b], [[0,9,z]], RR, M, "RR", "M" ),
        % coalesce combines 3?
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],a,b,c], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],b,a,c], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],c,b,a], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],c,a,b], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],b,c,a], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,2],[b,3],[c,2],a,c,b], [[0,9,z]], RR, M, "RR", "M" ),
        % allocated block (possibly) in middle
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],[c,3],a,c,[d,5]], [[0,9,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],c,a,[e,2],[f,4]], [[0,6,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],c,a,[e,2],[f,4],e], [[0,6,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],d,a,[f,4]], [[0,6,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],d,a,[f,4],c,[g,4]], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],d,[f,4],a,c,[g,4]], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],d,[f,4],a,c,[g,2]], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],d,[f,4],[g,2],f], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],c,[g,2],d,[f,4]], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],c,[f,4],d], [[0,8,z]], RR, M, "RR", "M" ),

        % allocated block (possibly) in middle
	all3or4(  TryHarderFlag, Which, [[a,2],[c,2],[d,2],c,a,[e,2],[f,4]], [[0,8,z]], RR, M, "RR", "M" ),

        % allocated block (possibly) in middle
	all3or4(  TryHarderFlag, Which, [[a,2],[b,2],[c,2],[d,2],d,a,[e,2],b,[f,4]], [[0,8,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],[c,3],a,c], [[0,9,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],[c,3],a], [[0,9,z]], RR, M, "RR", "M" ),

	all3or4(  TryHarderFlag, Which, [[b,3],[c,3]], [[0,3,z],[3,3,a],[6,3,z]], RR, M, "RR", "M" ),
	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],[c,3],a,c,[d,5]], [[0,2,e],[2,9,z]], RR, M, "RR", "M" ).
	%% note: we will not test queries like this one.
	%  its MemList has an unaccounted for gap.
	%  (that should not cause any real difficulty,
	%   but we will not test that.)
	%%	all3or4(  TryHarderFlag, Which, [[a,3],[b,3],[c,3],a,c,[d,5]], [[0,3,z],[3,6,z]], RR, M, "RR", "M" ),

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A3 and A4,
 * whose names are in the string SA3 and SA4.
 */
all4iioo(Predicate,A1,A2,A3,A4,SA3,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), printstring(SA3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA3), printstring(" = "),
	write(A3), nl,
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A2 and A4,
 * whose names are in the string SA2 and SA4.
 */
all4ioio(Predicate,A1,A2,A3,A4,SA2,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl,
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A4, whose name is in the string SA4.
 * like all4iiio, but sorts.
 */
sort4iiio(Predicate,A1,A2,A3,A4,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4],
	findall(A4,call(T),L),
	sort(L,SL),
	printstring("SL"), printstring(" = "),
	write(SL), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A4, whose name is in the string SA4.
 */
all4iiio(Predicate,A1,A2,A3,A4,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A3, whose name is in the string SA3.
 */
all3iio(Predicate,A1,A2,A3,SA3) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), printstring(SA3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA3), printstring(" = "),
	write(A3), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A1, whose name is in the string SA1.
 */
all3oii(Predicate,A1,A2,A3,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A2, whose name is in the string SA2.
 */
all3ioi(Predicate,A1,A2,A3,SA2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(","), write(A3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A2 and A3,
 * whose names are in the string SA2 and SA3.
 */
all3ioo(Predicate,A1,A2,A3,SA2,SA3) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(","), printstring(SA3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl,
	printstring(SA3), printstring(" = "),
	write(A3), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2
 * assume output goes to A2, whose name is in the string SA2.
 */
all2io(Predicate,A1,A2,SA2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1, A2
 * assume output goes to A1, whose name is in the string SA1.
 */
all2oi(Predicate,A1,A2,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(","), write(A2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1 and A2
 * assume yes or no as output.
 */
all2ii(Predicate,A1,A2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2],
	((call(T),printstring("yes"));( \+ T ,printstring("no"))),
	nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * assume output goes only to A1, whose name is in the string SA1.
 */
all1o(Predicate,A1,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(")"), nl,
	T =..[Predicate,A1], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * assume output goes only to A1, whose name is in the string SA1.
 */
all1ostring(Predicate,A1,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(")"), nl,
	T =..[Predicate,A1], call(T),
	printstring(SA1), printstring(" = "),
	printstring(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * input is A1;
 * as with other testing predicates,
 * output is yes if success or nothing if failure.
 * (written to make generates all possible yes answers too.)
 */
all1i(Predicate,A1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(")"), nl,
	T =..[Predicate,A1],
        call(T), printstring("yes"),
	nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate
 * no input, no output;
 * as with other testing predicates,
 * output is yes if success or nothing if failure.
 * (written to make generates all possible yes answers too.)
 */
all0(Predicate) :-
	printstring("testing: "), write(Predicate), nl,
	T =..[Predicate],
        call(T), printstring("yes"),
	nl, nl,
	fail; true.

/* a way to output strings. */
printstring([]).
printstring([H|T]) :- put(H), printstring(T).

/* specialized tester for TryHarder
 */
all3or4(TryHarderFlag, Predicate,A1,A2,A3,A4,SA3,SA4) :-
	(TryHarderFlag = 0,
	 all3iio(Predicate,A1,A2,A4,SA4)
	)
       ;
	(TryHarderFlag = 1,
	 all4iioo(Predicate,A1,A2,A3,A4,SA3,SA4)
	)
       .


/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A3 and A4,
 * whose names are in the string SA3 and SA4.
 */
all5iiooo(Predicate,A1,A2,A3,A4,A5,SA3,SA4,SA5) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), printstring(SA3),
	printstring(","), printstring(SA4),
	printstring(","), printstring(SA5),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4,A5], call(T),
	printstring(SA3), printstring(" = "),
	write(A3), nl,
	printstring(SA4), printstring(" = "),
	write(A4), nl,
	printstring(SA5), printstring(" = "),
	write(A5), nl, nl,
	fail; true.

% re-consult your code:
ys :-   consult('sched.pl').
% re-consult everything:
yy :-
	consult('sched.pl'),
	consult('../test.pl').

% useful to save typing (but mainly for me, not students since they
% will rarely need to reload test.pl within a session) ...
yt :- consult('../test.pl').
